# 前言

首先，在Android开发中跨进程通信是很重要且应该是每个开发者都应该要去掌握的知识点。而在大部分的普通应用中由于业务简单，所以往往使用单个进程即可满足所有业务。这也导致还是有一部分开发人员虽然工作多年，但对于跨进程通信也依旧是`只闻其声，却不见其人`的情况。因此，这篇文章将会尽可能详细的讲述跨进程通信中最为常用的方式之一：AIDL（Android Interface Definition Language）。

### IPC（进程间通信）

在学习使用AIDL之前，我们先要简单了解一下IPC的相关概念。**IPC**（Inter-Process Communication）为进程间通信或跨进程通信，是指两个进程之间进行间通信的过程。在Android 中，为每个进程都分配了一个独立的虚拟机，不同虚拟机在内存分配上都有不同的地址空间，互相访问数据需要借助其他手段。

### 问题：Android 上的 IPC 跨进程通信是如何工作的？

Android 中有多种方式可以实现 IPC：

- `Bundle`：用于在四大组件之间传递信息，只能使用它支持的数据类型。

- `文件共享`：两个进程通过读/写同一个文件来进行交换数据。

- `ContentProvider`：主要用来对提供数据库方面的共享。

- `Socket`：主要用在网络方面的数据交换。

- `Messenger`：一种轻量级的 IPC 方案，它的底层实现是 AIDL，可以在不同进程中传递 Message.。一次只处理一个请求，在服务端不需要考虑线程同步的问题，服务端不存在并发执行的情形。在远程的服务中，声明一个 Messenger，使用一个 Handler 用来处理收到的消息。

- `AIDL`：Messenger 是以`串行`的方式处理客户端发来的消息，如果大量消息同时发送到服务端，服务端只能一个一个处理，所以大量并发请求就不适合用 Messenger ，而且 Messenger 只适合传递消息，不能`跨进程`调用服务端的方法，而AIDL 可以解决并发和跨进程调用方法的问题。

|      名称       |                             优点                             |                             缺点                             |                           使用场景                           |
| :-------------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|     Bundle      |                           简单易用                           |                 只能传输Bundle支持的数据类型                 |                     四大组件间的进程通信                     |
|    文件共享     |                           简单易用                           |        不适合高并发场景，并且无法做到进程间的即时通信        |       无并发访问的情形，交换简单的数据实时性不高的场景       |
|    **AIDL**     |        **功能强大，支持一对多并发通信，支持实时通信**        |              **使用稍复杂，需要处理好线程同步**              |                  **一对多通信且有RPC需求**                   |
|    Messenger    |          功能一般，支持一对多串行通信，支持实时通信          | 不能很好处理高并发情形，不支持RPC，数据通过Message进行传输，因此只能传输Bundle支持的数据类型 | 低并发的一对多即时通信，无RPC需求，或者无需要返回结果的RPC需求 |
| ContentProvider | 在数据源访问方面功能强大，支持一对多并发数据共享，可通过Call方法扩展其它操作 |       可以理解为受约束的AIDL，主要提供数据源的CRUD操作       |                   一对多的进程间的数据共享                   |
|     Socket      |   功能强大，可以通过网络传输字节流，支持一对多并发实时通信   |            实现细节稍微有点繁琐，不支持直接的RPC             |                         网络数据交换                         |

> 多进程开发通过进程隔离、资源独立分配和增强并发处理能力，提供了许多好处，尤其在需要高安全性和模块化的应用中。然而，这种架构也带来了资源消耗、开发复杂性和调试难度的增加。开发者在选择多进程架构时，需要权衡这些优缺点，并根据具体的业务需求和系统环境来做出最佳决策。

# 一、AIDL应用

AIDL（Android Interface Definition Language）是 Android 提供的一种机制，用于定义两个进程之间的接口，以便实现进程间通信（IPC）。AIDL的架构可以看作是一种CS（Client-Server）架构，即客户端-服务端架构。这在 Android 开发中非常有用，尤其是当你需要创建跨进程服务时。

在大部分普通的手机应用上，一般都是一个应用只需一个进程就可以满足全部的业务，很少会涉及除了系统服务外的进程间交互的情况。而在大型app或者系统级应用（如：车载应用）上则基本都会存在多个进程。

- **大型复杂应用**

  当应用包含多个独立且复杂的模块时，多进程开发有助于提高模块的隔离性和稳定性。例如，一个大型应用可以分为多个模块，每个模块作为独立进程运行，通过 AIDL 实现模块间的数据和功能共享。

- **跨进程组件**

  需要多个应用共享某些组件或服务时，可以考虑将这些组件放在独立进程中，便于多个进程访问。例如，一个音乐播放器应用可以通过 AIDL 提供一个服务，允许其他应用控制音乐播放。

- **复杂数据传递**

  AIDL 支持传递复杂的数据类型，如对象、集合等。对于需要在不同进程之间传递复杂数据的场景，AIDL 非常适用。例如，一个电子商务应用可以通过 AIDL 服务提供商品信息，前台应用可以查询和显示商品详情。

### 多进程开发的优点：

#### 1. **增强应用稳定性和隔离性**

- **进程隔离**：每个进程在自己的内存空间中运行，进程之间不会直接干扰。因此，如果某个进程崩溃，不会直接影响到其他进程。对于 Android 应用，如果某个模块出现问题导致进程崩溃，主应用的其他部分仍能继续运行。
- **安全性提升**：通过将敏感操作或数据放在独立的进程中，可以减少整个应用被攻击的风险。例如，Android 中一些安全敏感的操作可以放在独立的进程中运行。

#### 2. **资源分配和管理更灵活**

- **资源独立**：不同进程可以独立地管理和分配资源（如内存、CPU 时间等），避免单个进程占用过多资源导致系统不稳定。对于大型应用，将内存消耗较大的模块（如多媒体处理、数据解析等）放在独立进程中，可以更好地管理内存使用。
- **提高并发能力**：多进程可以充分利用多核处理器的能力，在多核系统上，每个进程可以在不同的 CPU 核心上运行，从而提高应用的并发处理能力。

#### 3. **提升系统响应速度**

- **避免主进程阻塞**：将耗时操作（如网络请求、复杂计算等）放在独立进程中执行，可以避免主进程（通常是 UI 进程）被阻塞，提升应用的响应速度和用户体验。
- **后台任务独立运行**：后台任务可以在独立的进程中运行，不会影响前台任务的流畅性。

#### 4. **更容易扩展和维护**

- **模块化设计**：多进程架构有助于模块化开发，不同功能模块可以作为独立的进程进行开发和维护。这使得应用的扩展性更好，开发团队可以并行工作，减少相互干扰。

### 多进程开发的缺点：

#### 1. **资源消耗增加**

- **内存开销**：每个进程需要独立的内存空间来运行，导致内存使用量增加。这对资源受限的设备（如移动设备）可能会造成压力，进而影响整个系统的性能。
- **上下文切换开销**：进程间的上下文切换比线程间的切换更加昂贵，因为每次切换都涉及到操作系统内核态和用户态的转换，影响整体的执行效率。

#### 2. **复杂的进程间通信 (IPC)**

- **开发难度增加**：多进程开发需要通过 IPC（如 Binder、Socket、Shared Memory 等）来进行进程间的数据交换和协作。这不仅增加了代码复杂度，还可能引入同步、死锁等并发问题。
- **性能开销**：由于进程间通信通常需要序列化和反序列化数据，尤其是在传递大数据量时，性能开销较大，通信延迟增加。

#### 3. **调试和测试复杂化**

- **调试困难**：多进程环境下，调试变得更加复杂。问题可能发生在某个进程中，但影响了其他进程的表现，导致问题定位变得更加困难。
- **测试挑战**：多进程间的交互逻辑增加了测试的复杂性，需要更为精细的测试用例设计来覆盖进程间的交互和异常处理。

#### 4. **启动和管理复杂**

- **启动延迟**：启动新进程会带来一定的延迟，尤其是在移动设备上，可能会影响应用的启动时间和用户体验。
- **进程管理复杂**：需要设计合理的进程生命周期管理策略，以应对进程的创建、销毁、重启等情况，防止进程过多导致系统资源枯竭。

# 二、AIDL基础

### AIDL 支持的数据类型

#### 1. 基本数据类型：`int`、`long`、`float`、`double`、`boolean`、`char`、`byte`

AIDL 支持所有 Java 中的基本数据类型，基本类型传输效率高，适用于简单的进程间通信。

#### 2. String 和 CharSequence

- **String**：字符串类型，是最常用的数据类型之一，适用于传输文本信息。

- **CharSequence**：字符序列接口，类似于 `String`，但可以表示更广泛的字符序列。

#### 3. List

AIDL 支持 `List` 类型，但有以下要求：

- 必须使用 `ArrayList` 实现类。

- `List` 中的元素类型必须是 AIDL 支持的类型，如基本数据类型、`String`、`Parcelable` 对象等。

- 可以指定 `in`、`out` 或 `inout` 参数方向，但大多数情况下使用 `in`。

#### 4. Map

- AIDL 支持 `Map` 类型，但必须使用 `HashMap` 实现类。

- `Map` 中的键和值必须是 AIDL 支持的类型。

#### 5. Parcelable

AIDL 支持自定义的 `Parcelable` 类型，用于传递复杂的对象。但有以下注意事项：

- 自定义的类需要实现 `Parcelable` 接口。
- 需要创建一个对应的 `aidl` 文件。
- 在使用自定义数据类型的文件中，需要手写`import`来导入自定义的`Parcelable` 类型。

**示例：**

定义一个 `PersonInfo` 类并实现 `Parcelable` 接口：

```kotlin
package me.marko.server

import android.os.Parcel
import android.os.Parcelable

class PersonInfo() : Parcelable {

    var name: String? = null
    var age: Int = 0

    constructor(parcel: Parcel) : this() {
        name = parcel.readString()
        age = parcel.readInt()
    }

    override fun writeToParcel(parcel: Parcel, flags: Int) {
        parcel.writeString(name)
        parcel.writeInt(age)
    }

    override fun describeContents(): Int {
        return 0
    }

    companion object CREATOR : Parcelable.Creator<PersonInfo> {
        override fun createFromParcel(parcel: Parcel): PersonInfo {
            return PersonInfo(parcel)
        }

        override fun newArray(size: Int): Array<PersonInfo?> {
            return arrayOfNulls(size)
        }
    }
}
```

在 AIDL 文件中声明 `Parcelable` 对象：

```aidl
// PersonInfo.aidl
package me.marko.server;

parcelable PersonInfo;
```

在AIDL文件中使用自定义类型：

```java
// IServerInterface.aidl
package me.marko.server;

// 需要手写import
import me.marko.server.PsersonInfo;

interface IServerInterface {

    String getName();

    void sendDataInfo(in PersonInfo info);
}
```

> AIDL中只支持 Java 语法，并不支持 Kotlin。

### 定向Tag

在上面的`IServerInterface.aidl`文件中，使用自定义对象做参数时使用了`in`进行标记。

```java
void sendDataInfo(in PersonInfo info);
```

而在AIDL中，这种用来指定参数在进程间传递时方向的修饰符，叫做`定向tag`。有如下几个：

#### 1. **`in` 修饰符**

- **方向**：`in` 表示参数是从客户端传递到服务端。
- 特点：
  - 这种参数是只读的，服务端只能读取它的值，不能修改传回给客户端。
  - `in` 是默认修饰符，如果在 AIDL 文件中不指定修饰符，AIDL 会默认将参数视为 `in`。
  - 适用于传递简单的值或对象引用，避免在服务端改变原始数据。

#### 2. **`out` 修饰符**

- **方向**：`out` 表示参数是从服务端传递回客户端的。
- 特点：
  - 这种参数在客户端调用方法时并没有实际的值，服务端负责为它分配值，并将其传回给客户端。
  - `out` 参数在方法调用时会被重写，所以客户端传入的初始值会被忽略。
  - 适用于需要从服务端获取结果或数据的场景。

#### 3. **`inout` 修饰符**

- **方向**：`inout` 表示参数既可以从客户端传递到服务端，也可以从服务端传回客户端。
- 特点：
  - 这种参数在服务端既可以读取传入的初始值，也可以对其进行修改，并将修改后的值传回给客户端。
  - `inout` 适用于参数在方法调用中需要被修改并返回的场景。

#### 使用注意事项

- **性能**：`in` 参数传递的数据通常是按值传递，而 `out` 和 `inout` 参数可能涉及到数据的复制和重新分配，这会增加 IPC（进程间通信）的开销。因此，除非有必要，否则应尽量使用 `in` 参数以提高效率。
- **安全性**：对于敏感数据，使用 `in` 参数可以防止服务端意外或恶意地修改数据，因为这些数据在客户端是只读的。
- 适用场景：
  - **`in`**：用于传递只读数据，如方法的输入参数。
  - **`out`**：用于传递由服务端生成或计算的结果。
  - **`inout`**：用于既要传递数据到服务端，又要从服务端获取修改后的结果的场景。

#### 4. `oneway`修饰符

`oneway` 是 AIDL 中的一个关键字，**用于定义单向（异步）接口方法**。当一个方法被声明为 `oneway` 时，方法调用是非阻塞的，即客户端调用这个方法后，不需要等待服务端完成处理就可以继续执行其他代码。这个机制特别适用于不需要返回结果的操作，或者操作完成的时间较长但不需要立即反馈的场景。

 **`oneway` 的使用方式：**

在 AIDL 接口文件中，`oneway` 关键字用于方法的前缀。例如：

```java
interface IExample {
    oneway void performLongRunningOperation();
}
```

**特点：**

- **异步调用**：`oneway` 方法的调用是异步的，客户端调用该方法后立即返回，而不需要等待服务端完成处理。

- **无返回值**：`oneway` 方法不能有返回值，方法的返回类型必须是 `void`。这是因为异步调用不保证客户端能够接收到处理结果。

- **方法执行顺序**：由于是异步调用，多个 `oneway` 方法的执行顺序在服务端是不确定的。因此，在设计接口时需要考虑到可能的并发问题。

**适用场景：**

- **后台任务**：适用于那些在后台执行、不需要立即反馈的任务，比如文件下载、数据库操作等。
- **广播式通知**：当需要通知服务端某个事件发生时，而不关心处理结果，可以使用 `oneway` 方法。

# 三、项目实战

为了便于理解进程间通信，下面将会创建`server(服务端)`和`client(客户端)`两个不同进程的模块。`server`端将提供 api 给 `client`端调用，两个进程之间将通过 aidl 通信。

## Server模块编写

#### 1. 如何创建一个aidl文件

Android Studio为我们提供了快速创建 aidl 文件的方式，在`server`模块中右键，如下图：

<img src="D:/Android/Blogs/helloaidl/image-20240828161218661.png" alt="image-20240828161218661" style="zoom:80%;" />

> Tip：如果你在上图第3步中跟我的不一样，并且无法点击，那是因为新版Android Studio需要在`build.gradle`中添加如下配置来启用。
>
> ```groovy
> android {
>     ...
> 
> 	// 添加如下代码
>     buildFeatures {
>         aidl true
>     }
> }
> ```

编辑文件名，点击`Finish`。如下图：

![image-20240829141208766](D:/Android/Blogs/helloaidl/image-20240829141208766.png)

最后，Android Studio将会生成以下内容。如下图：

![image-20240829143109593](D:/Android/Blogs/helloaidl/image-20240829143109593.png)

> Tips：`main/aidl`下的`me/marko/server`路径可以自定义，并不需要与包名一致。



IServerInterface.aidl 文件中的示例：

```java
interface IServerInterface {
    /**
     * 演示可以在AIDL中用作参数和返回值的一些基本类型。
     */
    void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat,
            double aDouble, String aString);
}
```



